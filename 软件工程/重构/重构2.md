# 第6章 重新组织函数

## 6.1 Extract Method（提炼函数）

## 6.2 Inline Method（内联函数）

## 6.3 Inline Temp（内联临时变量）

## 6.4 Replace Temp with Query（以查询函数或者只读属性取代临时变量）

## 6.4 Introduce Explaining Variable（引入解释性变量）

## 6.6 Split Temporary Variable（分解临时变量）

### 简述

你的程序有某个临时变量被赋值超过一次，它既不是循环变量，也不被用于收集计算结果。

**针对每次赋值， 创造一个独立、对应的临时变量**。

### 动机

如果临时变量承担多个责任，就应该被替换（分解）为多个临时变量，每个变量只承担一个责任（即只赋值一次）。同一个临时变量承担两件事情，会令代码阅读者糊涂。

### 做法

P128

## 6.6 Remove Assignements to Parameters（移除对参数的赋值）

### 简述

代码对一个参数进行赋值

**以一个临时变量取代该参数的位置**

### 动机

“对参数赋值”降低了代码的清晰度，混用了按值传递和按引用传递这两种参数传递方式。

入参数和出参数不在讨论范围内。（ref，in，out参数）

### 做法

P132

## 6.8 Replace Method with Method Object（以函数对象取代函数）

### 简述

你有一个大型函数，其中对局部变量的使用使你无法采用Extract Method。

**将这个函数放进一个单独对象中，如此一来局部变量就成了对象内的字段。然后你就可以在同一个对象中将这个大型函数分解为多个小型函数。**

### 动机

一个函数中局部变量泛滥成灾，导致分解非常困难。

## 6.9 Substitute Algorithm（替换算法）

### 简述

你想要把某个算法替换为另一个更为清晰的算法。

**将函数本体替换为另一个算法**。



# 第7章 在对象之间搬移特性



## 7.1 Move Method（搬移函数）

## 简述

你的程序中，有个函数与其所驻类之外的另一个类进行更多交流：调用后者，或者被后者调用。

**在该函数最常引用的类中建立一个有着类似行为的新函数。将旧函数变成一个单纯的委托函数，或是将旧函数完全移除。**

## 动机

“搬移函数”是重构理论的支柱。如果一个类有太多行为，或如果一个类与另一个类有太多合作而形成高度耦合，就应该搬移函数。



## 7.2 Move Field（搬移字段）

在你的程序中，某个字段被其所驻类之外的另一个类更多地用到。

**在目标类新建一个字段，修改源字段的所有用户，令它们改用新字段**。



## 7.3 Extract Class（提炼类）

### 简述

某个类做了应该由两个类做的事。

**建立一个新类，将相关的字段和函数从旧类搬移到新类。**



## 7.4 Inline Class（将类内联化）

### 简述

某个类没有做太多事情。

**将这个类的所有特性搬移到另一个类中，然后移除原类。**



## 7.5 Hide Delegate（隐藏“委托关系”）

### 简述

客户通过一个委托类来调用另一个对象。

**在服务类上建立客户所需要的所有函数，用以隐藏委托关系。**

### 动机

“封装”意味着每个对象都应该尽可能少了解系统的其他部分。如此一来，一旦发生变化，需要了解这一变化的对象就会比较少。

如果某个客户先通过服务对象的字段得到另一个对象，然后调用后者的函数，那么客户就必须知晓这一层委托关系。万一委托关系发生变化，客户也得相应变化。你可以在服务对象上放置一个简单的委托函数，将委托关系隐藏起来，从而去除这种依赖。



## 7.6 Remove Middle Man（移除中间人）

### 简述

某个类做了过多的简单委托动作。

**让客户直接调用委托类。**



## 7.7 Introduce Foreign Method（引入外加函数，即C#中的扩展方法）

### 简述

你需要为提供服务的类增加一个函数，但你无法修改这个类。

**在客户类中建立一个函数，并以第一参数形式传入一个服务类实例。**



### 7.8 Intruduce Local Extension（引入本地扩展）

### 简述

你需要为服务类提供一些额外函数，但你无法修改这个类。

**建立一个新类，使它包含这些函数。让这个扩展品成为源类的子类（继承）或包装类（组合）。**

使用子类（继承）优点是工作量少，可直接复用原来的字段和方法。

缺点是：

* 必须能够控制对象的创建。若对象是由某个外部模块的直接返回的，那子类就没用了。
* 子类化方案必须产生一个新的对象。在“类继承”体系中，子对象和原对象是完全不同的两个对象。若原对象被其他部分持有，且修改，则我们新建的子对象并不能得到这个修改信息，导致出现不一致。

当上述缺点发生在我们项目中时，我就应考虑使用包装类（组合）的方案。

包装类的缺点是：

* 需要为原始类的每一个函数和字段提供委托访问的函数。
* 无法完美处理“接收原始类实例作为参数的函数”的问题。





