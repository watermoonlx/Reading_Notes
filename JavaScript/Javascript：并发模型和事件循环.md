# 并发模型和事件循环

Javascript拥有一个基于“事件循环（event loop）”的并发模型。这个模型与其他语言（例如c和java）的模型有很大的区别。

## 运行时概念（Runtime concepts）

下面的几个小节解释了理论模型。现代的Javascript引擎实现并极度优化了该理论模型。

### 运行时内存示意图

![运行时内存示意图](https://developer.mozilla.org/files/4617/default.svg)

### 栈Stack

函数调用会创建栈帧。

```javascript
function f(b){
    var a=12;
    return a:b+35;
}

function g(x){
    var m=4;
    return f(m*x);
}

g(21);
```

当调用函数`g`时，第一个栈帧被创建，其内部包含`g`的参数和本地变量。当`g`调用`f`，第二个栈帧被创建，并被push到第一个栈帧的上面。当`f`返回时，处于栈顶的`f`的栈帧被弹出（只剩`g`的栈帧）。当`g`返回时，`g`的栈帧被弹出，整个栈就被清空了。

### 堆Heap

对象都被放置在堆中。堆这个名字指代大容量的非结构化的内存区域。

### 消息队列Queue

Javascript运行时拥有一个消息队列，其内部包含等待处理的消息列表。一个函数与一条消息相关联。当栈为空的时候，一条消息将从消息队列中被取出并被处理。处理过程包括调用与之关联的函数（因此也即会创建一个初始栈帧）。当栈再度弹空之时，消息处理过程也就结束了。

## 事件循环（Event Loop）

“事件循环”是因其常见的实现方式而得名的，其实现常常如下：

```javascript
while(queue.waitForMessage()){
  queue.processNextMessage();
}
```

当消息队列中没有消息需要处理时，`queue.waitForMessage`将同步等待消息的到来。

### "Run-to-completion"

只有当当前消息处理完全完成之后，才会开始处理下一条消息。这个特性将提供一些有用的性质以方便你“推理（reasoning about）”你的代码，比如，在Javascript中，一个函数在执行时不能被暂停，必须完全执行完成后才能执行其他代码。这与C不同，在C中若一个函数运行于一个线程，它可以随时暂停这个函数并运行其他线程。

这个单线程模型的缺点是，如果一条消息的处理花费了太长的时间，则Web应用将无法响应用户操作，比如点击和滚动。浏览器将弹出“a script is taking too long to run”的提示框。最佳实践是，尽量让消息处理的时间短。如果可能，尽量将一条消息分割成多条小的消息。

### 添加消息

在浏览器中，当浏览器事件被触发，且注册了相应的事件处理函数时，便会添加一条消息到消息队列中。若为注册事件处理函数，则该事件便被丢弃。比如，若一个元素的Click事件绑定了事件处理函数，则当点击该元素的时候，一条消息便被加入消息队列。其他事件也是如此。

调用`setTimeout`方法，将会在第二个参数指定的时间后将一条消息添加到消息队列。如果消息队列中没有其他消息，则该条消息将立即被处理。但如果消息队列中已经有其他消息，则该消息必须等待其他消息处理完成之后，才能被处理。因此，`setTiemeout`的第二个时间参数，只是指定了回调函数调用的最少间隔时间，而非保证多长时间后运行。

### 零延迟（Zero delays）

零延迟并不是指回调函数能够在0ms后立即被调用。当以0毫秒作为参数调用`setTimeout`时，并不会真的立即调用回调函数。真正的执行时间依消息队列中等待执行的任务而定。

### 多个运行时间的通信

每个web worker和跨域的iframe拥有自己的栈、堆和消息队列。两个不同的运行时只能通过`postMessage`方法来传递数据。当一个运行时监听了message事件时，另一个运行时可以通过`postMessage`方法向它发送数据。

## 永不阻塞（Never blocking）

Javascript的事件循环模型的一个非常有趣的性质是，它永远不会阻塞，这与其他语言不相同。通常使用事件和回调函数处理I/O，所以当Web应用在等待IndexedDB查询或者XHR请求返回时，它依然能够处理其他事情，比如用户输入。（发送请求之前会注册事件处理函数，发送完请求后，函数立即退出，消息处理完成。知道请求返回，处理函数才会被加入到消息队列中。）

有极少的历史遗留的例外，比如alert或者同步XHR，但最佳实践是避免使用它们。